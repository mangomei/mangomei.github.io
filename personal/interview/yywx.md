## 深圳元宇万象一面

## 自我介绍

## redis的数据类型及其应用场景？
### 5大基础类型
* 字符串（String）：可以存储`字符串`、`整数`或者`浮点数`。常用于`缓存`、`计数器`、`分布式锁`等场景。
* 哈希表（Hash）：由多个`键值对`组成，可以用于存储对象或者复杂数据类型。常用于存储`用户信息`、`文章信息`等。
* 列表（List）：由多个元素组成的`有序集合`，可以用于存储`最新消息`、操作日志等。可以在列表的头部或者尾部添加或者删除元素。
* 集合（Set）：由多个元素组成的`无序集合`，可以用于`去重、关注列表、共同好友列表`等场景。可以对集合进行交集、并集、差集等操作。
* 有序集合（Sorted Set）：由多个元素和对应的`分值组成的有序集合`，可以用于`排行榜`、`评分系统`等场景。可以对有序集合进行排名、范围查询等操作。

### 3大高级类型


## redis如何实现分布式锁？
1. 线程在获取锁时，调用`setnx`获取一个key(可以加入业务ID)，设置成功则表示获取到锁。
2. 执行完业务逻辑后，调用delete key来释放锁。
3. 在获取key的时候，如果获取失败，可延迟适当时间后重新获取。
4. 获取锁成功后，可以为key设置过期时间，防止业务逻辑异常未正确释放锁导致死锁。

## redis实现分布式锁的缺点？
1. 锁竞争问题：高并发下，很多个客户端同时获取同一把锁，需要让获取失败的客户端进行重试等待，或者使用红锁算法。
2. 锁过期问题：由于过期时间过快，网络延迟、锁释放不正确等问题，可能导致锁失效。因此需要在获取锁时设置合理的过期时间和唯一标识，并在释放锁时检查过期时间和唯一标识（可以用lua脚本确保原子性），确保锁被即时释放。或者使用红锁算法规避掉网络延迟对单点的影响。
3. 高可用问题：Redis是单点存储的，若节点宕机，整个系统的锁就会失效。需要使用redis集群或者其他分布式锁实现方案，如zookeeper。


## 如果某个key在过期的瞬间，被线程A获取到，redis已经把锁对应的key给删除，导致线程A无法正常释放锁，如何解决？
在获取锁的时候设置唯一标识和过期时间，在释放锁的时候检查唯一标识和过期时间，如果已经过期则忽略。
或者使用红锁算法，利用多节点加锁机制提高可用性。

## Redis中红锁是什么？
是实现可靠的、高可用的分布式锁的方法。

红锁算法的基本思想是，在多个Redis节点之间进行锁协作。具体来说，当一个客户端尝试获取锁时，它会向多个Redis节点发送加锁请求，如果多数节点成功获取到了锁，则认为加锁成功。这种方式可以提高锁的可靠性，避免了单点故障的问题。同时，红锁算法也通过使用“随机性”和“抖动”来提高锁的可用性和可靠性，从而进一步提高了分布式锁的效率和可靠性。

## 说说分布式事务原理？
是跨越多个节点的事务，需要协调多个参与者的操作，保证都成功或者都失败。
主要有如下实现方式：

1. 2PC协议（2阶段提交）
2PC协议是最常用的分布式事务协议，它采用“两阶段提交”的方式来协调分布式事务。2PC协议的实现复杂，但能够保证事务的一致性和可靠性。

2. TCC事务（补偿性事务）
TCC事务是一种补偿性事务，它通过在每个参与者中实现“尝试（try）”、“确认（confirm）”和“取消（cancel）”三个操作来实现事务的提交和回滚。TCC事务的实现相对简单，但需要应用程序对业务逻辑进行分解。

3. 基于消息的事务
基于消息的事务是一种异步事务，它通过消息队列来实现事务的提交和回滚。在基于消息的事务中，每个参与者都将操作封装成消息发送到消息队列中，如果所有消息都发送成功，则事务提交成功，否则进行回滚操作。基于消息的事务能够实现高可用性和可伸缩性，但需要应用程序对消息传递进行处理。

4. 最终一致性事务
最终一致性事务是一种弱一致性事务，它通过异步复制来实现数据的最终一致性。在最终一致性事务中，参与者提交事务时不需要等待其他参与者的响应，数据最终一致性由后台的异步复制机制来保证。最终一致性事务的实现相对简单，但需要应用程序进行一些额外的逻辑处理。

在选择分布式事务的实现方式时，需要根据应用场景和需求进行选择。
例如，如果要求事务的一致性和可靠性较高，则可以选择2PC协议；如果需要实现高可用性和可伸缩性，则可以选择基于消息的事务。

## 你说的是强一致性，那弱一致性如何实现？
可以基于消息队列来实现。

## 消息队列如何保证发送消息不丢失？

1. 消息确认机制
   同步确认机制ack：默认为1，leader接收成功并确认后表示消息发送成功；
                  值为0，表示不管leader和follow是否接收成功，都表示成功。
                  值为-1/all，表示leader和follow都需要接收成功且确认后，才表示发生成功。

2. 消息持久化
   消息队列将消息持久化到磁盘上，防止异常断电后丢失。

3. 内存和磁盘双写

4. 多副本，避免分区故障导致消息丢失

5. 发送者重试机制
